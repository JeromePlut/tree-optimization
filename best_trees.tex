\documentclass{article}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[margin=20mm]{geometry}
\usepackage{math}
\usepackage{unicode}
\usepackage{booktabs}
\usepackage{newunicodechar}
\usepackage{bbm}
\newunicodechar{ùüô}{\mathbbm{1}}
\makeatletter
\let\listORI\list
\def\FB@listsettings{%
      \setlength{\itemsep}{0.4ex plus 0.2ex minus 0.2ex}%
      \setlength{\parsep}{0.4ex plus 0.2ex minus 0.2ex}%
      \setlength{\topsep}{0.8ex plus 0.4ex minus 0.4ex}%
      \setlength{\partopsep}{0.4ex plus 0.2ex minus 0.2ex}%
      \@tempdima=\parskip
      \addtolength{\topsep}{-\@tempdima}%
      \addtolength{\partopsep}{\@tempdima}}%
\def\list#1#2{\listORI{#1}{\FB@listsettings #2}}%
\makeatother
      
\def\pcost{ŒΩ_\mathrm{p}}
\def\scost{ŒΩ_\mathrm{c}}
\def\treefrom#1{\left\{#1\right\}}
\newcounter{proofcase}
\newenvironment{proofcases}{\setcounter{proofcase}{0}%
	\def\item{\stepcounter{proofcase}\medskip
	(\roman{proofcase})~}}{}
\def\gcost{ŒΩ}
	

\DeclareMathOperator\Exp{Exp} % Polya exponential
\begin{document}

\section{Optimal trees}


\begin{df}
We recursively define a \emph{weighted tree} (with coefficients in some
group~$G$) as either:
\begin{enumerate}
\item a \emph{leaf}, \emph{i.e.} a single weight~$w ‚àà G$; or
\item an \emph{inner node}, i.e. a set of
$k$~\emph{branches}~$\treefrom{b_1, ‚Ä¶, b_k}$, for an integer~$k ‚â• 2$,
which themselves are weighted trees.
\end{enumerate}
\end{df}

We consider \emph{non-planar} trees,
which means that the set of branches is unordered.
\emph{Trees} are weighted trees such that all leaves have weight~$1$.
The \emph{total weight}~$W(t)$ of a weighted tree is
the sum of the weight of all its leaves;
the weight of a tree is thus simply the count of its leaves.

% We write~$\ro T(n)$ for the set of trees with $n$~leaves.
% Our main interest in this work lies with non-weighted trees;
% however, weighted trees are a useful tool for studying them.
% A weighted tree can thus be used to represent
% a simplified form of the base structure of a full tree:
% the leaves of the weighted trees represent branches of the full tree,
% and the weight of each such leaf is then the number of leaves
% in the corresponding sub-tree.

% \begin{df}
% Let~$\ro T(n)$ be the set of all non-planar trees
% with $n$ leaves such that no node has a single child.
% \end{df}
% 
% We use the following syntax for trees: $L$ is the tree with only one
% leaf, and given trees $t_1, ‚Ä¶, t_n$, we write $\treefrom{t_1, ‚Ä¶, t_n}$
% for the tree where $(t_i)$ are the branches of the root node.
% Note that, since our trees are non-planar, this tree
% does not depend on the ordering of the trees~$t_i$.

\subsection{Cost functions}
% \begin{df}
% For any function~$f: ‚Ñ§ ‚Üí ‚Ñ§$,
% we define the \emph{$f$-cost} $c_f(t)$ of a weighted tree~$t$ by:
% \begin{enumerate}
% \item if $t$~is a leaf~$w$, then $c_f(t) = w$;
% \item if $t = \acco{b_1, ‚Ä¶, b_k}$ and $t$~has total weight~$n$
% then $c_f(t) = f(k) ‚ãÖ n + ‚àë c_f(b_i)$.
% \end{enumerate}
% In particular, we define the \emph{parent cost}~$\pcost(t)$
% as the cost associated with~$f(k) = 1$,
% and its \emph{sibling cost}~$\scost(t)$
% as the cost associated with~$f(k) = k-1$.
% \end{df}


\begin{df}
We define the \emph{parent cost}~$\pcost(t)$ 
and \emph{sibling cost}~$\scost(t)$
of a weighted tree~$t$ in the following way:
\begin{enumerate}
\item if $t$~is a leaf with weight~$w$,
then $\pcost(t) = \scost(t) = w$;
\item if $t$~is an inner node~$\treefrom{b_1, ‚Ä¶, b_k}$
with total weight~$n$,
then
\begin{align}
\pcost(t) = n + ‚àë \pcost(b_i); \qquad
\scost(t) = (k-1) n + ‚àë \scost(b_i).
\end{align}
\end{enumerate}
\end{df}
In particular, if $t$~is binary then, since $k = 2$ for all inner nodes,
$\scost(t) = \pcost(t)$.

While our main interest lies in simple (non-weighted) trees,
weighted trees can be used as shortcuts for studying them.
Namely, let~$t'$ be the (weighted) tree obtained from a (weighted) tree~$t$
by collapsing an inner branch~$b$ to a single leaf
with weight~$\pcost(b)$;
it is then obvious from the definition that~$\pcost(t') = \pcost(t)$.
The same result also holds for~$\scost$.

This allows replacing a tree~$t$ with a possibly large number of leaves
by a simpler collapsed weighted tree~$t'$ with a small number of leaves,
where the weight of each leaf of~$t'$ represents the cost of
a large sub-tree of~$t$.

\subsection{Optimal trees}

% For any tree~$t ‚àà \ro T(n)$, we define
% \begin{enumerate}
% \item the \emph{parent cost} of~$t$:
% $\pcost(L) = 0$, $\pcost(\treefrom{t_1, ‚Ä¶, t_k}) = ‚àë \pcost(t_i) + n$.
% \item the \emph{sibling cost} of~$t$:
% $\scost(L) = 0$, $\scost(\treefrom{t_1, ‚Ä¶, t_k}) = ‚àë \scost(t_i) + (k-1) n$.
% \item the \emph{geometric cost} of~$t$
% as the point~$\gcost(t) = (\pcost(t), \scost(t)) ‚àà ‚Ñù^2$.
% \end{enumerate}
% In particular, if $t$~is a binary tree
% then $\scost(L) = \pcost(L)$.
% 
For any tree~$t$,
the \emph{cost function} associated to~$t$
is the affine map~$f_t: Œª ‚Ü¶ Œª \pcost(t) + \scost(t)$.
For any set~$T$ of trees,
we define~$f_T(Œª) = \inf \acco{f_t(Œª),\; t ‚àà T}$;
as an infimum of affine functions, $f_T$ is a concave function.
In fact, it is the dual of the convex hull
of the set~$\acco{ \gcost(t),\; t ‚àà T}$:

\begin{prop}\label{prop:convex}
Let~$(t_i)$ be the set of points on the lower-left convex hull of
$G = \acco{\gcost(t),\: t ‚àà T}$,
\emph{i.e.} those points~$t$ such that $G$ intersects non-trivially
the upper-right quadrant originated at~$t$.
Assume that $(t_i) = (t_1, ‚Ä¶, t_n)$ is finite
and that they are sorted by decreasing value of~$\pcost(t_i)$;
define $Œª_i = \frac{\scost(t_{i+1})-\scost(t_i)}{\pcost(t_{i+1})-\pcost(t_i)}$.
Then, for any~$œÑ ‚àà [Œª_{i-1}, Œª_i]$, $f_T(œÑ) = f_{t_i}(œÑ)$;
that is, the tree~$t_i$ minimizes $f_{t}(œÑ)$ for all~$t ‚àà T$.
\end{prop}



\subsection{Counting trees}
The single-child condition ensures that $\ro T(n)$~is a finite set for any~$n$.
Let~$T$ be the generating series $T(z) = ‚àë \abs{\ro T(n)}\: z^n$;
then $T$~satisfies the functional equation
\begin{align}
T(z) = x + \Exp(T)(z) - T(z) - 1,
\end{align}
where $\Exp(T)$ is the Polya exponential, defined by
$\Exp(f)(z) = ‚àë_{n‚â•0} f(x^n)/n$.

(TODO)


\subsection{Cost functions for some families of trees}

In this section we study a few given families of trees,
parametrized by their number of leaves~$n$;
empirically, these are the optimal families for~$Œª$ small.
While it is possible to check this for small~$n$,
the exponential growth of the number of trees
(see previous section)
prevents this exploration from going beyond, say, $n = 25$.
We believe it reasonable to conjecture that
these families remain optimal in the given domains
among all trees for all values of~$n$.


\subsubsection{Tree-like integration and derivation}

We now introduce a tool which will enable us to
systematically compute the parent and sibling costs
for some infinite families of trees.
The main result is Prop.~\ref{prop:interpolation},
which allows the computation of tree-like integrals
of finite sequences of integers.


Let~$d ‚â• 2$ be an integer.
For any function~$f: ‚Ñï ‚Üí ‚Ñù$ we define the
\emph{tree-like derivative} of~$f$ by
\begin{align}\label{eq:def-D}
\go D(f)(n) &= f(n) - ‚àë_{i=0:d-1} f\pa{\floor{\frac{n+i}{d}}}.
\end{align}
One easily checks that $\go D(f)(0) =\go D(f)(1) = (1-d) f(0)$.
We also define the \emph{tree-like integral}
of any function~$f$ such that~$f(1) = f(0)$ by
\begin{align}\label{eq:def-I}
\go I(f)(n) &= \begin{cases}
\frac{1}{1-d}f(0)  & \text{for~$n = 0$ or~$n = 1$},\\
\displaystyle f(n) + ‚àë_{i=0:d-1} \go I_d(f)\pa{\floor{\frac{n+i}{d}}}
	& \text{for $n ‚â• 2$.}
\end{cases}
\end{align}
% (The condition~$f(1) = f(0)$ is necessary for
% the definition of~$\go I(f)(1)$ to make sense).
When the degree~$d$ is not obvious we shall write it as a subscript,
thus $\go D_d$, $\go I_d$.


The operator~$\go I$ is a right inverse of~$\go D$;
that is, $\go D ‚àò \go I$ is the identity
on functions such that~$f(0) = f(1)$.
In fact, $\go D$ and~$\go I$ are inverse linear automorphisms of this space.

% We also define the following sequences:
% $ùüô(n) = 1$; $J(n) = 1$ for~$n = 0$ and~$n$ for~$n ‚â• 1$;
% $U(n) = 1$ for~$n ‚â§ 1$ and~$0$ for~$n ‚â• 2$;
% $E_d(n) = e ‚ãÖ n - \frac{d^e}{d-1}$ for~$n ‚àà [d^e, d^{e+1}]$
% and~$E_d(0) = E_d(1) = \frac{1}{1-d}$.
% Then one easily checks the following relations:
% \begin{align}
% \go D(ùüô) = \go I(ùüô) = (1-d)‚ãÖùüô; \qquad
% % \go D(J) = -U; \qquad
% \go I(J) = E_d.
% \end{align}


\medbreak

We now introduce the notation for affine interpolation
as it will be used in Prop.~\ref{prop:interpolation}.
For~$x ‚àà ‚Ñù$, let~$Œõ(x) = \frac 12 \abs{x-1} + \frac 12 \abs{x+1} -
\abs{x}$; then $Œõ$ is continuous, piecewise affine,
and~$Œõ(0) = 1$ while~$Œõ(n) = 0$ for~$n ‚àà ‚Ñ§‚ßµ \acco{0}$.
For any sequence~$(y_i)$ of integers,
we define the function~$\widehat{y}(x) = ‚àë y_i Œõ(x-i)$;
this function is also continuous, piecewise affine,
and interpolates~$(y_i)$.

\begin{prop}\label{prop:interpolation}
Let~$(y_i)$ be a sequence of real numbers such that~$y_0 = y_1$
and let~$(z_i) = \go D(y)$;
assume there exists an integer~$c$ such that~$z_i = 0$ for~$i ‚â• d^c$.
Let~$\widehat{y}$ be the piecewise affine function
interpolating the values~$(y_{d^{c-1}}, ‚Ä¶, y_{d^{c}-1},
y_{d^c} = d y_{d^{c-1}})$.
Then, for any integers~$e$ and~$n ‚àà [d^{c+e}\!,\: d^{c+e+1}]$:
\begin{align}
y_n &= n^e\, \widehat{y}\pa{n/d^e}.
\end{align}
% Let~$(y_i)$ be a sequence of real numbers
% such that~$y_0 = y_1$ and~$y_i = 0$ for~$i ‚â• d^c$.
% Let~$f$ be the unique function interpolating~$(y_i)$
% which is affine on each interval~$[i, i+1]$,
% with the additional condition that~$f(d^c) = d f(d^{c-1})$.
% Then, for any integer~$n ‚àà [d^{c+e}, d^{c+e+1}]$,
% $\go I(y)(n) = d^e f(n/d^e)$.
\end{prop}

\begin{proof}
We first note that~$z_{d^{c}} = 0$ implies~$y_{d^c} = d y_{d^{c-1}}$.
We prove the result by induction on~$e$; the case~$e = 0$ is obvious.
Let~$n ‚àà [d^{c+e+1}, d^{c+e+2}]$
and write~$n = a d + b$ be the Euclidan division of~$n$ by~$d$;
then the relation~$z_{n} = 0$ implies
\begin{align}
y_n &= ‚àë y_{\floor{\frac{n+i}{d}}}\\
 &= (d-b) y_{a} + b y_{a+1}\\
 &= d^e \pa{(d-b) \widehat{y}(a/d^e) \,+\, b \widehat{y}((a+1)/d^e)}.
% \go I(y)(n) &= y(n) + ‚àë \go I(y)\pa{\floor{\frac{y+i}{d}}}\\
% &= 0 + (d-b) \go I(y)(a) + b \go I(y)(a+1)\\
% &= d^e \pa{(d-b) f\pa{\frac{a}{d^e}} + b f\pa{\frac{a+1}{d^e}}}.
\end{align}
Since $\widehat{y}$~is affine on
the interval~$\cro{\frac{a}{d^e}, \frac{a+1}{d^e}}$,
the last value is also equal to $\widehat{y}\pa{a+b/d}{d^e}$.
\end{proof}


\begin{prop}
Define the functions~$J(n) = \max(n, 1)$
and, for any~$n ‚àà [d^e, d^{e+1}]$, $E_d(n) = (e+1)‚ãÖn - \frac{d^{e+1}}{d-1}$.
Then
\begin{align}
\go I_d(J) = E_d.
\end{align}
\end{prop}
% $E_d(n) = e ‚ãÖ n - \frac{d^e}{d-1}$ for~$n ‚àà [d^e, d^{e+1}]$
% and~$E_d(0) = E_d(1) = \frac{1}{1-d}$.
% We check that $\go I_d(J) = E_d$.

% \begin{prop}\label{prop:IU}
% Define~$f_d(x) = \frac{d-2}{d-1}-x$ for~$x ‚â§ 2$
% and~$f_d(x) = \frac{-d}{d-1}$ for~$x ‚â• 2$.
% Then, for any integer~$n ‚â• 1$, if~$e = \floor{\log_d(n)}$,
% $\go I_d(J)(n) = d^e f_d(n/d^e)$.
% \end{prop}

\subsubsection{Regular families of trees}

Let~$(d_n)$ be a sequence of integers such that~$d_0 = d_1 = 0$.
The \emph{regular family of trees} with degrees~$(d_n)$
is the family of trees~$(T(n))$ with $n$ leaves
such that, for~$n ‚â• 2$,
$T(n) = \acco{T\pa{\floor{\frac{n+i}{d(n)}}},\, i=0‚Ä¶d(n)-1}$.
We can compute the parent costs and sibling costs
of some regular families using Prop.~\ref{prop:interpolation}.

\begin{prop}
Let~$d$ be an integer and define the family of trees~$T_d$
as the regular family of trees with degrees~$\min(n,d)$ for~$n ‚â• 2$.
Then the parent cost and sibling cost of~$T_d(n)$ are
\begin{align}
\pcost(T_d(n)) &= E_d(n) - f_d(n) = \begin{cases}
(e+2) n - 2 d^e & \text{for~$n ‚àà [d^e, 2 d^e]$,}\\
(e+1) n & \text{for~$n ‚àà [2 d^e, d^{e+1}]$.}
\end{cases}\\
\scost(T_d(n)) &= ((d-1)e + 2b)‚ãÖn - b(b+1)‚ãÖd^e
\quad \text{for $n ‚àà [b‚ãÖd^e, (b+1)‚ãÖd^e]$, $b ‚àà \acco{1, ‚Ä¶, d-1}$.}
\end{align}
\end{prop}

\begin{proof}
Let~$u = \pcost(T_d) - E_d$.
Then we check that $\go D_d(u)(n) = 0$ for any~$n ‚â• d$.
Thus, by Prop.~\ref{prop:interpolation}, for any~$n ‚àà [d^e, d^{e+1}]$,
$u(n) = d^e \widehat{u}(n/d^e)$
where~$\widehat{u}$ is the affine interpolation of~$u$ on~$\acco{1,‚Ä¶,d}$.
then, by Prop.~\ref{prop:interpolation},
It now suffices to check that $\widehat{u}(x) = \frac{d-2}{d-1} - x$
for~$x ‚àà [1,2]$ and~$-\frac{d}{d-1}$ for~$x ‚àà [2,d]$.

The computation of~$\scost(T_d)$ uses the same reasoning.
Let~$v = \scost(T_d) - (d-1) E_d$; then $\go D_d(v) = 0$ for~$n ‚â• d$.
For~$n ‚àà \acco{1,‚Ä¶,d}$, we find $v_n = n(n-1) - (d-1)E_d(n) = n^2 -d n + d$,
so that, for~$x ‚àà [b,b+1]$, $\widehat{v}(x) = (2b-d+1) x + (d-b^2-b)$.
\end{proof}

Using the same process (which can easily be automated),
we can compute the parent and sibling costs
for some explicitly defined regular families of trees.

\begin{prop}
Let~$T_{2,3}$ be the regular family of trees
with degrees~$d_2 = 2$, $d_3 = 3$ and~$d_n = 2$ for~$n ‚â• 4$. Then:
\begin{align}
\pcost(T_{2,3}(n)) &= \begin{cases}
e‚ãÖ n & \text{for $n ‚àà [2^e, \frac{3}{2} ‚ãÖ 2^e]$,}\\
(e+4)‚ãÖn - 6 ‚ãÖ 2^e & \text{for $n ‚àà [\frac{3}{2}‚ãÖ2^e, 2^{e+1}]$.}\end{cases}\\
\scost(T_{2,3}(n)) &= \begin{cases}
(e+3)‚ãÖn - 3‚ãÖ2^e & \text{for~$n ‚àà [2^e, \frac{3}{2}‚ãÖ2^e]$,}\\
(e+1)‚ãÖn & \text{for~$n ‚àà [\frac{3}{2}‚ãÖ2^e, 2^{e+1}]$.}\end{cases}
\end{align}
\end{prop}

\begin{prop}
Define the following regular families of trees:
\begin{enumerate}
\item $T_{3,2}$ with degrees~$d_2 = 2$, $d_4 = 2$ and~$d_n = 3$ otherwise;
\item $T_3$ with degrees $d_2 = 2$ and $d_n = 3$ otherwise;
\item $T_{3,4}$ with degrees $d_2 = 2$, $d_4 = 4$ and~$d_n = 3$ otherwise.
\end{enumerate}
The following table summarizes the costs of these families:
\begin{align}
\begin{array}{lllll}
\toprule
\text{for $n$ in:} &
{}[3^e, 4‚ãÖ3^{e-1}] &
{}[4‚ãÖ3^{e-1}, 5‚ãÖ3^{e-1}] &
{}[5‚ãÖ3^{e-1}, 2‚ãÖ3^e] &
{}[2‚ãÖ3^e, 3^{e+1}]\\
\midrule
\pcost(T_{3,2}(n)): & (e+4)‚ãÖn-4‚ãÖ3^e & e‚ãÖn-4‚ãÖ3^{e-1} &
 (e+2)‚ãÖn - 2‚ãÖ3^e & (e+1)‚ãÖn\\
\scost(T_{3,2}(n)): & 2e‚ãÖn & (2e+4)‚ãÖn - 16‚ãÖ3^{e-1} &
 (2e+2)‚ãÖn - 2‚ãÖ3^e & (2e+4)‚ãÖn - 6‚ãÖ3^e \\
\midrule
\pcost(T_{3}(n)): & & (e+2)‚ãÖn-2‚ãÖ3^e & & (e+1)‚ãÖn \\
\scost(T_{3}(n)): & & (2e+2)‚ãÖn-2‚ãÖ3^e & & (2e+4)‚ãÖn-6‚ãÖ3^e\\
\midrule
\pcost(T_{3,4}(n)): & e‚ãÖn & (e+4)‚ãÖn-16‚ãÖ3^{e-1} &
	(e+2)‚ãÖn-2‚ãÖ3^e & (e+1)‚ãÖn \\
\scost(T_{3,4}(n)): & (2e+4)‚ãÖn - 4‚ãÖ3^e & 2e‚ãÖn + 4‚ãÖ3^{e-1} &
	(2e+2)‚ãÖn-2‚ãÖ3^e & (2e+4)‚ãÖn - 6‚ãÖ3^e \\
\bottomrule
\end{array}
\end{align}
\end{prop}

% \subsubsection{Binary trees $T_2(n)$}
% 
% We define the family of \emph{binary trees}~$T_2(n)$ by
% $T_2(1) = L$ and $T_2(n) = \treefrom{T_2(\floor{n/2}),
% T_2(\ceil{n/2})}$ for~$n ‚â• 2$;
% 
% \begin{prop}\label{prop:cost-T2}
% For any integer~$n$, let~$b = \floor{\log_2(n)}$. Then
% $\pcost(T_{2}(n)) = \scost(T_2(n)) = (b+2)‚ãÖn - 2^{b+1}$;
% \end{prop}
% 
% 
% \begin{proof}
% First note that, since $T_2(n)$ is binary,
% $\scost(T_2(n)) = \pcost(T_2(n))$.
% 
% On the other hand, using the notations from~(\ref{eq:def-D}),
% we see that $\go D(\pcost(T_2) - J)$ is $
% 
% 
% We prove the result for~$\pcost(T_2(n))$ by induction.
% If $n = 2 n'$ is even then $b' = \floor{\log_2(n')} = b-1$,
% so that $\pcost(T_2(n)) = n + 2 \pcost(T_2(n'))
%  = n + 2 (b+1)(n/2) - 2‚ãÖ 2^b = (b+2) n - 2^{b+1}$ as required.
% In the case where~$n = 2^{b+1}-1$,
% one has $n = 2n'+1$ with $n' = 2^{b}-1$,
% so that $\floor{\log_2(n')} = b-1$
% while $\floor{\log_2(n'+1)} = b$;
% we check that $n + \pcost(T_2(n')) + \pcost(T_2(n'+1))
% %  = (2‚ãÖ2^b - 1) + (b+1)(2^b-1) - 2^b + (b+2) 2^b - 2‚ãÖ2^b
% %  = (2+b+1-1+b+2-2) 2^b -1-b-1
%  = (2b+2) 2^b - (b+2)
%  = (b+2)‚ãÖn-2^{b+2}$ as expected.
% In the other cases, $b' = \floor{\log_2(n')} = \floor{\log_2(n'+1)} = b-1$;
% the proof is then similar.
% \end{proof}
% 
% \subsubsection{Binary-ternary trees $T_{23}(n)$}
% 
% We define the family of \emph{binary-ternary trees}~$T_2(n)$ by
% $T_{23}(1) = L$,
% $T_{23}(3‚ãÖ2^k) = \treefrom{T_{23}(2^k), T_{23}(2^k), T_{23}(2^k)}$,
% and $T_{23}(n) = \treefrom{T_{23}(\floor{n/2}), T_{23}(\ceil{n/2})}$
% otherwise.
% 
% In particular, one easily checks that $T_{23}(n) = T_2(n)$
% whenever $n$~is a power of two.
% 
% \begin{prop}\label{prop:cost-T23}
% Let~$n$ be an integer, $b = \floor{\log_2(n)}$,
% and $x = n/2^{b+1}$. Then:
% \begin{enumerate}
% \item $\pcost(T_{23}(n)) =
% \begin{cases}
% b‚ãÖn & \text{if $1/2 ‚â§ x ‚â§ 3/4$,}\\
% (b+4)‚ãÖn - 6‚ãÖ2^{b} & \text{if $3/4 ‚â§ x < 1$.}
% \end{cases}$
% \item $\scost(T_{23}(n)) =
% \begin{cases}
% (b+3)‚ãÖn - 3‚ãÖ2^b & \text{if $1/2 ‚â§ x ‚â§ 3/4$,}\\
% (b+1)‚ãÖn & \text{if $3/4 ‚â§ x < 1$.}
% \end{cases}$
% \end{enumerate}
% (Note that for cases~(ii) and~(iii), both values coincide for~$x = 3/4$).
% \end{prop}
% 
% 
% \begin{proof}
% \begin{proofcases}
% \item
% The result is easy to check by induction for~$n = 2^b$.
% The case of~$n = 3 ‚ãÖ 2^{b-1}$ follows.
% We prove the remaining cases by induction.
% Assume that $n = 2n'$ is even,
% so that $\pcost(T_{23}(n') = n + 2 \pcost(T_{23}(n'))$;
% then one has $b' = \floor{\log_2(n')} = b-1$
% and~$x' = n'/2^{b'} = x$.
% If $x ‚â§ 3/4$ then $\pcost(T_{23}(n')) = b'‚ãÖn'$,
% so that $\pcost(T_{23}(n)) = n + 2 (b-1)(n/2) = bn$.
% If $x > 3/4$ then $\pcost(T_{23}(n')) = (b'+4)‚ãÖn' - 6‚ãÖ2^{b'}$,
% so that $\pcost(T_{23}(n)) = n + 2((b-1)+4)(n/2) - 12‚ãÖ2^{b-1}
%  = (b+4) n - 6‚ãÖ2^{b}$.
% Finally, if $n = 2n'+1$ is odd,
% then $b' = \floor{\log_2(n')} = \floor{\log_2(n'+1)} = b-1$,
% and $n'/2^{b'}$, $(n'+1)/2^{b'}$ are $> 3/4$ exactly when $n/2^b > 3/4$.
% The result then follows in the same way.
% 
% \item
% \end{proofcases}
% \end{proof}
% 
% As a simple consequence of Props.~\ref{prop:cost-T2}
% and~\ref{prop:cost-T23} we obtain the following slope:
% 
% \begin{prop}\label{prop:slope-T2-T23}
% For any integer~$n$, with the same notations as in
% Prop.~\ref{prop:cost-T23}:
% \begin{align}
% \gcost(T_{23}(n)) - \gcost(T_{2}(n)) &=
% \begin{cases}
% \rlap{$(n - 2^b)$}\hphantom{(2^{b+1}-n\;\;} (-2,1) & \text{if $x‚â§ 3/4$},\\
% (2^{b+1} - n) (-2,1) & \text{if $x ‚â• 3/4$}.
% \end{cases}
% \end{align}
% In particular, the segment~$(\gcost(T_2(n)), \gcost(T_{23}(n)))$
% is either degenerate (when $n$~is a power of~two)
% or has slope~$-\frac 12$.
% \end{prop}
% 
% \subsubsection{Ternary-binary trees $T_{32}(n)$}
% 
% The tree family $T_{32}(n)$ is defined in the following way:
% \begin{align}
% T_{32}(n) &= \begin{cases}
% \treefrom{T_{32}(\floor{n/2}), T_{32}(\floor{(n+1)/2})}
% 	&\text{if $6‚ãÖ2^b < n < 9‚ãÖ2^b$ for some integer~$b$,}\\
% \treefrom{T_{32}(\floor{n/3}), T_{32}(\floor{(n+1)/3}),
% 	T_{32}(\floor{(n+2)/3})}
% 	&\text{if $9‚ãÖ2^b ‚â§ n ‚â§ 6‚ãÖ2^b$}.
% \end{cases}
% \end{align}
% 
% \subsubsection{(Almost) Ternary trees $T_3(n)$}
% 
% Since ternary trees always have an odd number of leaves,
% the trees $T_3(n)$ are not always ternary.
% They are defined by $T_3(1) = L$,
% $T_3(2) = \treefrom{L,L}$,
% $T_3(4) = \treefrom{T_3(2), T_3(2)}$,
% $T_3(5) = \treefrom{T_3(3), T_3(2)}$,
% and otherwise $T_3(n) = \treefrom{T_3(\floor{n/3}),
% 	T_3(\floor{(n+1)/3}), T_3(\floor{(n+2)/3})}$.
% 
% \begin{prop}
% Let~$n$ be an integer, $b = \floor{\log_3(n)}$,
% and $x = n/3^{b+1}$. Then:
% \begin{enumerate}
% \item $\pcost(T_{3}(n)) =
% \begin{cases}
% (b+4)‚ãÖn - 4‚ãÖ3^{b} & \text{if $1/3 ‚â§ x ‚â§ 4/9$,}\\
% (b+1)‚ãÖn & \text{if $4/9 ‚â§ x < 1$.}
% \end{cases}$
% % \item $\scost(T_{3}(n)) =
% % \begin{cases}
% % (b+3)‚ãÖn - 3‚ãÖ2^b & \text{if $1/2 ‚â§ x ‚â§ 3/4$,}\\
% % (b+1)‚ãÖn & \text{if $3/4 ‚â§ x < 1$.}
% % \end{cases}$
% \end{enumerate}
% (Note that for cases~(ii) and~(iii), both values coincide for~$x = 3/4$).
% \end{prop}
% 
% 

\end{document}
